// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const editPicture = `-- name: EditPicture :exec
UPDATE users
SET 
 picture = COALESCE(NULLIF($1,''),picture),
 updated_at = NOW()
WHERE id = $2
`

type EditPictureParams struct {
	Column1 interface{}
	ID      uuid.UUID
}

func (q *Queries) EditPicture(ctx context.Context, arg EditPictureParams) error {
	_, err := q.db.ExecContext(ctx, editPicture, arg.Column1, arg.ID)
	return err
}

const editRevoke = `-- name: EditRevoke :exec
UPDATE users
SET 
 revoked = $1,
 updated_at = NOW()
WHERE id = $2
`

type EditRevokeParams struct {
	Revoked sql.NullBool
	ID      uuid.UUID
}

func (q *Queries) EditRevoke(ctx context.Context, arg EditRevokeParams) error {
	_, err := q.db.ExecContext(ctx, editRevoke, arg.Revoked, arg.ID)
	return err
}

const editUser = `-- name: EditUser :exec
UPDATE users
SET 
  picture = COALESCE(NULLIF($1,''),picture),
  bio = COALESCE(NULLIF($2,''),bio),
  phone_number = COALESCE(NULLIF($3,''),phone_number),
  updated_at = NOW()
WHERE id = $4
`

type EditUserParams struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	ID      uuid.UUID
}

func (q *Queries) EditUser(ctx context.Context, arg EditUserParams) error {
	_, err := q.db.ExecContext(ctx, editUser,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.ID,
	)
	return err
}

const findByEmail = `-- name: FindByEmail :one
SELECT id,email,username,picture
FROM users
WHERE email = $1
`

type FindByEmailRow struct {
	ID       uuid.UUID
	Email    string
	Username sql.NullString
	Picture  sql.NullString
}

func (q *Queries) FindByEmail(ctx context.Context, email string) (FindByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, findByEmail, email)
	var i FindByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Picture,
	)
	return i, err
}

const findById = `-- name: FindById :one
SELECT id,email,username,picture
FROM users
WHERE id = $1
`

type FindByIdRow struct {
	ID       uuid.UUID
	Email    string
	Username sql.NullString
	Picture  sql.NullString
}

func (q *Queries) FindById(ctx context.Context, id uuid.UUID) (FindByIdRow, error) {
	row := q.db.QueryRowContext(ctx, findById, id)
	var i FindByIdRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Picture,
	)
	return i, err
}

const findByUserName = `-- name: FindByUserName :one
SELECT id,email,username,picture
FROM users
WHERE username = $1
`

type FindByUserNameRow struct {
	ID       uuid.UUID
	Email    string
	Username sql.NullString
	Picture  sql.NullString
}

func (q *Queries) FindByUserName(ctx context.Context, username sql.NullString) (FindByUserNameRow, error) {
	row := q.db.QueryRowContext(ctx, findByUserName, username)
	var i FindByUserNameRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Picture,
	)
	return i, err
}

const googlelogin = `-- name: Googlelogin :one
INSERT INTO users(username,email,picture,google_id,login_option)
VALUES ($1,$2,$3,$4,'google')
RETURNING id, email, username,picture
`

type GoogleloginParams struct {
	Username sql.NullString
	Email    string
	Picture  sql.NullString
	GoogleID sql.NullString
}

type GoogleloginRow struct {
	ID       uuid.UUID
	Email    string
	Username sql.NullString
	Picture  sql.NullString
}

func (q *Queries) Googlelogin(ctx context.Context, arg GoogleloginParams) (GoogleloginRow, error) {
	row := q.db.QueryRowContext(ctx, googlelogin,
		arg.Username,
		arg.Email,
		arg.Picture,
		arg.GoogleID,
	)
	var i GoogleloginRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Picture,
	)
	return i, err
}

const seeRevoke = `-- name: SeeRevoke :one
SELECT revoked 
FROM users
WHERE id = $1
`

func (q *Queries) SeeRevoke(ctx context.Context, id uuid.UUID) (sql.NullBool, error) {
	row := q.db.QueryRowContext(ctx, seeRevoke, id)
	var revoked sql.NullBool
	err := row.Scan(&revoked)
	return revoked, err
}

const singup = `-- name: Singup :one
INSERT INTO users(username,email,password)
VALUES ($1,$2,$3)
RETURNING id, email, username,picture
`

type SingupParams struct {
	Username sql.NullString
	Email    string
	Password string
}

type SingupRow struct {
	ID       uuid.UUID
	Email    string
	Username sql.NullString
	Picture  sql.NullString
}

func (q *Queries) Singup(ctx context.Context, arg SingupParams) (SingupRow, error) {
	row := q.db.QueryRowContext(ctx, singup, arg.Username, arg.Email, arg.Password)
	var i SingupRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Picture,
	)
	return i, err
}
